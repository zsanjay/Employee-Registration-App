import { ECalendarValue } from '../common/types/calendar-value-enum';
import { ChangeDetectorRef, EventEmitter, OnChanges, OnInit, SimpleChange, SimpleChanges } from '@angular/core';
import { IMonth } from './month.model';
import { MonthCalendarService } from './month-calendar.service';
import { Moment } from 'moment';
import { IMonthCalendarConfig, IMonthCalendarConfigInternal } from './month-calendar-config';
import { ControlValueAccessor, FormControl, ValidationErrors, Validator } from '@angular/forms';
import { CalendarValue } from '../common/types/calendar-value';
import { UtilsService } from '../common/services/utils/utils.service';
import { DateValidator } from '../common/types/validator.type';
import { SingleCalendarValue } from '../common/types/single-calendar-value';
import { INavEvent } from '../common/models/navigation-event.model';
import * as ɵngcc0 from '@angular/core';
export declare class MonthCalendarComponent implements OnInit, OnChanges, ControlValueAccessor, Validator {
    readonly monthCalendarService: MonthCalendarService;
    readonly utilsService: UtilsService;
    readonly cd: ChangeDetectorRef;
    config: IMonthCalendarConfig;
    displayDate: Moment;
    minDate: Moment;
    maxDate: Moment;
    theme: string;
    onSelect: EventEmitter<IMonth>;
    onNavHeaderBtnClick: EventEmitter<null>;
    onGoToCurrent: EventEmitter<void>;
    onLeftNav: EventEmitter<INavEvent>;
    onRightNav: EventEmitter<INavEvent>;
    onLeftSecondaryNav: EventEmitter<INavEvent>;
    onRightSecondaryNav: EventEmitter<INavEvent>;
    isInited: boolean;
    componentConfig: IMonthCalendarConfigInternal;
    yearMonths: IMonth[][];
    inputValue: CalendarValue;
    inputValueType: ECalendarValue;
    validateFn: DateValidator;
    _shouldShowCurrent: boolean;
    navLabel: string;
    showLeftNav: boolean;
    showRightNav: boolean;
    showSecondaryLeftNav: boolean;
    showSecondaryRightNav: boolean;
    api: {
        toggleCalendar: any;
        moveCalendarTo: any;
    };
    constructor(monthCalendarService: MonthCalendarService, utilsService: UtilsService, cd: ChangeDetectorRef);
    _selected: Moment[];
    get selected(): Moment[];
    set selected(selected: Moment[]);
    _currentDateView: Moment;
    get currentDateView(): Moment;
    set currentDateView(current: Moment);
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    init(): void;
    writeValue(value: CalendarValue): void;
    registerOnChange(fn: any): void;
    onChangeCallback(_: any): void;
    registerOnTouched(fn: any): void;
    validate(formControl: FormControl): ValidationErrors | any;
    processOnChangeCallback(value: Moment[]): CalendarValue;
    initValidators(): void;
    monthClicked(month: IMonth): void;
    onLeftNavClick(): void;
    onLeftSecondaryNavClick(): void;
    onRightNavClick(): void;
    onRightSecondaryNavClick(): void;
    toggleCalendarMode(): void;
    getMonthBtnCssClass(month: IMonth): {
        [klass: string]: boolean;
    };
    shouldShowCurrent(): boolean;
    goToCurrent(): void;
    moveCalendarTo(to: SingleCalendarValue): void;
    handleConfigChange(config: SimpleChange): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MonthCalendarComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<MonthCalendarComponent, "dp-month-calendar", never, { "config": "config"; "displayDate": "displayDate"; "minDate": "minDate"; "maxDate": "maxDate"; "theme": "theme"; }, { "onSelect": "onSelect"; "onNavHeaderBtnClick": "onNavHeaderBtnClick"; "onGoToCurrent": "onGoToCurrent"; "onLeftNav": "onLeftNav"; "onRightNav": "onRightNav"; "onLeftSecondaryNav": "onLeftSecondaryNav"; "onRightSecondaryNav": "onRightSecondaryNav"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9udGgtY2FsZW5kYXIuY29tcG9uZW50LmQudHMiLCJzb3VyY2VzIjpbIm1vbnRoLWNhbGVuZGFyLmNvbXBvbmVudC5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVDYWxlbmRhclZhbHVlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzL2NhbGVuZGFyLXZhbHVlLWVudW0nO1xuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0b3JSZWYsIEV2ZW50RW1pdHRlciwgT25DaGFuZ2VzLCBPbkluaXQsIFNpbXBsZUNoYW5nZSwgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSU1vbnRoIH0gZnJvbSAnLi9tb250aC5tb2RlbCc7XG5pbXBvcnQgeyBNb250aENhbGVuZGFyU2VydmljZSB9IGZyb20gJy4vbW9udGgtY2FsZW5kYXIuc2VydmljZSc7XG5pbXBvcnQgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgSU1vbnRoQ2FsZW5kYXJDb25maWcsIElNb250aENhbGVuZGFyQ29uZmlnSW50ZXJuYWwgfSBmcm9tICcuL21vbnRoLWNhbGVuZGFyLWNvbmZpZyc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgRm9ybUNvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMsIFZhbGlkYXRvciB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IENhbGVuZGFyVmFsdWUgfSBmcm9tICcuLi9jb21tb24vdHlwZXMvY2FsZW5kYXItdmFsdWUnO1xuaW1wb3J0IHsgVXRpbHNTZXJ2aWNlIH0gZnJvbSAnLi4vY29tbW9uL3NlcnZpY2VzL3V0aWxzL3V0aWxzLnNlcnZpY2UnO1xuaW1wb3J0IHsgRGF0ZVZhbGlkYXRvciB9IGZyb20gJy4uL2NvbW1vbi90eXBlcy92YWxpZGF0b3IudHlwZSc7XG5pbXBvcnQgeyBTaW5nbGVDYWxlbmRhclZhbHVlIH0gZnJvbSAnLi4vY29tbW9uL3R5cGVzL3NpbmdsZS1jYWxlbmRhci12YWx1ZSc7XG5pbXBvcnQgeyBJTmF2RXZlbnQgfSBmcm9tICcuLi9jb21tb24vbW9kZWxzL25hdmlnYXRpb24tZXZlbnQubW9kZWwnO1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgTW9udGhDYWxlbmRhckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIHtcbiAgICByZWFkb25seSBtb250aENhbGVuZGFyU2VydmljZTogTW9udGhDYWxlbmRhclNlcnZpY2U7XG4gICAgcmVhZG9ubHkgdXRpbHNTZXJ2aWNlOiBVdGlsc1NlcnZpY2U7XG4gICAgcmVhZG9ubHkgY2Q6IENoYW5nZURldGVjdG9yUmVmO1xuICAgIGNvbmZpZzogSU1vbnRoQ2FsZW5kYXJDb25maWc7XG4gICAgZGlzcGxheURhdGU6IE1vbWVudDtcbiAgICBtaW5EYXRlOiBNb21lbnQ7XG4gICAgbWF4RGF0ZTogTW9tZW50O1xuICAgIHRoZW1lOiBzdHJpbmc7XG4gICAgb25TZWxlY3Q6IEV2ZW50RW1pdHRlcjxJTW9udGg+O1xuICAgIG9uTmF2SGVhZGVyQnRuQ2xpY2s6IEV2ZW50RW1pdHRlcjxudWxsPjtcbiAgICBvbkdvVG9DdXJyZW50OiBFdmVudEVtaXR0ZXI8dm9pZD47XG4gICAgb25MZWZ0TmF2OiBFdmVudEVtaXR0ZXI8SU5hdkV2ZW50PjtcbiAgICBvblJpZ2h0TmF2OiBFdmVudEVtaXR0ZXI8SU5hdkV2ZW50PjtcbiAgICBvbkxlZnRTZWNvbmRhcnlOYXY6IEV2ZW50RW1pdHRlcjxJTmF2RXZlbnQ+O1xuICAgIG9uUmlnaHRTZWNvbmRhcnlOYXY6IEV2ZW50RW1pdHRlcjxJTmF2RXZlbnQ+O1xuICAgIGlzSW5pdGVkOiBib29sZWFuO1xuICAgIGNvbXBvbmVudENvbmZpZzogSU1vbnRoQ2FsZW5kYXJDb25maWdJbnRlcm5hbDtcbiAgICB5ZWFyTW9udGhzOiBJTW9udGhbXVtdO1xuICAgIGlucHV0VmFsdWU6IENhbGVuZGFyVmFsdWU7XG4gICAgaW5wdXRWYWx1ZVR5cGU6IEVDYWxlbmRhclZhbHVlO1xuICAgIHZhbGlkYXRlRm46IERhdGVWYWxpZGF0b3I7XG4gICAgX3Nob3VsZFNob3dDdXJyZW50OiBib29sZWFuO1xuICAgIG5hdkxhYmVsOiBzdHJpbmc7XG4gICAgc2hvd0xlZnROYXY6IGJvb2xlYW47XG4gICAgc2hvd1JpZ2h0TmF2OiBib29sZWFuO1xuICAgIHNob3dTZWNvbmRhcnlMZWZ0TmF2OiBib29sZWFuO1xuICAgIHNob3dTZWNvbmRhcnlSaWdodE5hdjogYm9vbGVhbjtcbiAgICBhcGk6IHtcbiAgICAgICAgdG9nZ2xlQ2FsZW5kYXI6IGFueTtcbiAgICAgICAgbW92ZUNhbGVuZGFyVG86IGFueTtcbiAgICB9O1xuICAgIGNvbnN0cnVjdG9yKG1vbnRoQ2FsZW5kYXJTZXJ2aWNlOiBNb250aENhbGVuZGFyU2VydmljZSwgdXRpbHNTZXJ2aWNlOiBVdGlsc1NlcnZpY2UsIGNkOiBDaGFuZ2VEZXRlY3RvclJlZik7XG4gICAgX3NlbGVjdGVkOiBNb21lbnRbXTtcbiAgICBnZXQgc2VsZWN0ZWQoKTogTW9tZW50W107XG4gICAgc2V0IHNlbGVjdGVkKHNlbGVjdGVkOiBNb21lbnRbXSk7XG4gICAgX2N1cnJlbnREYXRlVmlldzogTW9tZW50O1xuICAgIGdldCBjdXJyZW50RGF0ZVZpZXcoKTogTW9tZW50O1xuICAgIHNldCBjdXJyZW50RGF0ZVZpZXcoY3VycmVudDogTW9tZW50KTtcbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIGluaXQoKTogdm9pZDtcbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBDYWxlbmRhclZhbHVlKTogdm9pZDtcbiAgICByZWdpc3Rlck9uQ2hhbmdlKGZuOiBhbnkpOiB2b2lkO1xuICAgIG9uQ2hhbmdlQ2FsbGJhY2soXzogYW55KTogdm9pZDtcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZDtcbiAgICB2YWxpZGF0ZShmb3JtQ29udHJvbDogRm9ybUNvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgYW55O1xuICAgIHByb2Nlc3NPbkNoYW5nZUNhbGxiYWNrKHZhbHVlOiBNb21lbnRbXSk6IENhbGVuZGFyVmFsdWU7XG4gICAgaW5pdFZhbGlkYXRvcnMoKTogdm9pZDtcbiAgICBtb250aENsaWNrZWQobW9udGg6IElNb250aCk6IHZvaWQ7XG4gICAgb25MZWZ0TmF2Q2xpY2soKTogdm9pZDtcbiAgICBvbkxlZnRTZWNvbmRhcnlOYXZDbGljaygpOiB2b2lkO1xuICAgIG9uUmlnaHROYXZDbGljaygpOiB2b2lkO1xuICAgIG9uUmlnaHRTZWNvbmRhcnlOYXZDbGljaygpOiB2b2lkO1xuICAgIHRvZ2dsZUNhbGVuZGFyTW9kZSgpOiB2b2lkO1xuICAgIGdldE1vbnRoQnRuQ3NzQ2xhc3MobW9udGg6IElNb250aCk6IHtcbiAgICAgICAgW2tsYXNzOiBzdHJpbmddOiBib29sZWFuO1xuICAgIH07XG4gICAgc2hvdWxkU2hvd0N1cnJlbnQoKTogYm9vbGVhbjtcbiAgICBnb1RvQ3VycmVudCgpOiB2b2lkO1xuICAgIG1vdmVDYWxlbmRhclRvKHRvOiBTaW5nbGVDYWxlbmRhclZhbHVlKTogdm9pZDtcbiAgICBoYW5kbGVDb25maWdDaGFuZ2UoY29uZmlnOiBTaW1wbGVDaGFuZ2UpOiB2b2lkO1xufVxuIl19